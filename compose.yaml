# 允许服务相互通信的层。
networks:
  # 自定义的网络名称
  turing:
    # 指定该网络应使用哪个驱动程序。
    driver: bridge

# 服务是应用程序中计算资源的抽象定义，可以独立于其他组件进行扩展/替换。
services:
  turing-db:
    # 指定自定义容器名称，而不是生成的默认名称。
    container_name: turing-db
    # 定义容器中设置的环境变量。
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    # 声明运行以确定该服务的容器是否“健康”的检查。
    healthcheck:
      # 定义 Compose 运行以检查容器健康状况的命令。
      test: [ "CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}" ]
      # 运行状况检查将在容器启动后首先运行间隔秒，然后在之前的每个检查完成后再次运行间隔秒。
      interval: 10s
      # 如果单次运行检查花费的时间超过超时秒数，则检查被视为失败。
      timeout: 10s
      # 需要重试健康检查连续失败才能将容器视为不健康。
      retries: 3
      # 为需要时间引导的容器提供初始化时间。
      start_period: 40s
    # 声明用于服务容器的自定义主机名。
    hostname: turing-db
    # 指定启动容器的图像。
    image: postgres:17.6
    # 定义服务容器附加到的网络，引用顶级网络键下的条目。
    networks:
      - turing
    # 暴露端口。 指定两个端口 (HOST:CONTAINER)，或仅指定容器端口（选择临时主机端口）。
    ports:
      - "5432:5432"
    # 定义平台在容器终止时应用的策略。
    restart: always
    # 定义服务容器必须可以访问的挂载主机路径或命名卷。todo logging
    volumes:
      - ./docker/postgresql/data:/var/lib/postgresql/data

  # todo 有没有比 keycloak 更好的选择，OIDC Provider（例如 Keycloak、Auth0、Azure AD 等）
  # todo 创建的 89 张表直接在 turing 里了，如何设置下，使其存在另外一个 schema（数据库）中？
  turing-keycloak:
    # 指定自定义容器名称，而不是生成的默认名称。
    container_name: turing-keycloak
    # 覆盖容器镜像声明的默认命令（即 Dockerfile 的 CMD）。
    command:
      - start-dev
      - --http-port=8081
    # 表示服务之间的启动和关闭依赖关系。
    depends_on:
      turing-db:
        # 设置依赖关系被视为满足的条件。
        condition: service_healthy
    # 定义容器中设置的环境变量。
    environment:
      KC_BOOTSTRAP_ADMIN_USERNAME: admin
      KC_BOOTSTRAP_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD}
    # 声明运行以确定该服务的容器是否“健康”的检查。
    healthcheck:
      # 定义 Compose 运行以检查容器健康状况的命令。
      # https://www.keycloak.org/observability/health
      test: [ "CMD-SHELL", "{ printf 'HEAD /health/ready HTTP/1.0\r\n\r\n' >&0; grep 'HTTP/1.0 200'; } 0<>/dev/tcp/localhost/9000" ]
      # 运行状况检查将在容器启动后首先运行间隔秒，然后在之前的每个检查完成后再次运行间隔秒。
      interval: 10s
      # 如果单次运行检查花费的时间超过超时秒数，则检查被视为失败。
      timeout: 10s
      # 需要重试健康检查连续失败才能将容器视为不健康。
      retries: 3
      # 为需要时间引导的容器提供初始化时间。
      start_period: 40s
    # 声明用于服务容器的自定义主机名。
    hostname: turing-keycloak
    # 指定启动容器的图像。
    image: quay.io/keycloak/keycloak:26.4
    # 定义服务容器附加到的网络，引用顶级网络键下的条目。
    networks:
      - turing
    # 暴露端口。 指定两个端口 (HOST:CONTAINER)，或仅指定容器端口（选择临时主机端口）。
    ports:
      - "8081:8081"
    # 定义平台在容器终止时应用的策略。
    restart: always
    # 定义服务容器必须可以访问的挂载主机路径或命名卷。todo logging
    volumes:
      - ./docker/keycloak/data:/opt/keycloak/data
      - ./docker/keycloak/conf/keycloak.conf:/opt/keycloak/conf/keycloak.conf

  # todo 有没有比 redis 更好的选择
  turing-redis:
    # 覆盖容器镜像声明的默认命令（即 Dockerfile 的 CMD）。
    command: >
      bash -c '
        chmod +x /usr/local/bin/healthcheck.sh;
        redis-server --requirepass ${REDIS_PASSWORD} --bind "* -::*";
      '
    # 指定自定义容器名称，而不是生成的默认名称。
    container_name: turing-redis
    # 表示服务之间的启动和关闭依赖关系。
    depends_on:
      turing-db:
        # 设置依赖关系被视为满足的条件。
        condition: service_healthy
    # 声明运行以确定该服务的容器是否“健康”的检查。
    healthcheck:
      # 定义 Compose 运行以检查容器健康状况的命令。
      test: [ "CMD", "/usr/local/bin/healthcheck.sh" ]
      # 运行状况检查将在容器启动后首先运行间隔秒，然后在之前的每个检查完成后再次运行间隔秒。
      interval: 10s
      # 如果单次运行检查花费的时间超过超时秒数，则检查被视为失败。
      timeout: 10s
      # 需要重试健康检查连续失败才能将容器视为不健康。
      retries: 3
      # 为需要时间引导的容器提供初始化时间。
      start_period: 40s
    # 声明用于服务容器的自定义主机名。
    hostname: turing-redis
    # 指定启动容器的图像。
    image: redis:8.2.1
    # 定义服务容器附加到的网络，引用顶级网络键下的条目。
    networks:
      - turing
    # 暴露端口。 指定两个端口 (HOST:CONTAINER)，或仅指定容器端口（选择临时主机端口）。
    ports:
      - "6379:6379"
    # 定义平台在容器终止时应用的策略。
    restart: always
    # 定义服务容器必须可以访问的挂载主机路径或命名卷。todo logging
    volumes:
      - ./docker/redis/data:/data
      - ./docker/redis/sh/healthcheck.sh:/usr/local/bin/healthcheck.sh

  turing-backend:
    # 指定用于从源创建容器映像的构建配置。
    build:
      # 包含 Dockerfile 的目录的路径，或 git 存储库的 url。
      context: ./docker/turing-backend
      # Compose 使用备用文件进行构建。 还必须指定构建路径。
      dockerfile: Dockerfile
    # 指定自定义容器名称，而不是生成的默认名称。
    container_name: turing-backend
    # 表示服务之间的启动和关闭依赖关系。
    depends_on:
      turing-keycloak:
        # 设置依赖关系被视为满足的条件。
        condition: service_healthy
      turing-redis:
        # 设置依赖关系被视为满足的条件。
        condition: service_healthy
    # 声明运行以确定该服务的容器是否“健康”的检查。
    healthcheck:
      # 定义 Compose 运行以检查容器健康状况的命令。
      test: [ "CMD-SHELL", "curl http://localhost:8080/actuator/health | grep -q '^{\"status\":\"UP\"'" ]
      # 运行状况检查将在容器启动后首先运行间隔秒，然后在之前的每个检查完成后再次运行间隔秒。
      interval: 10s
      # 如果单次运行检查花费的时间超过超时秒数，则检查被视为失败。
      timeout: 10s
      # 需要重试健康检查连续失败才能将容器视为不健康。
      retries: 3
      # 为需要时间引导的容器提供初始化时间。
      start_period: 40s
    # 声明用于服务容器的自定义主机名。
    hostname: turing-backend
    # 指定启动容器的图像。
    image: turing-backend:0.0.1-SNAPSHOT
    # 定义服务容器附加到的网络，引用顶级网络键下的条目。
    networks:
      - turing
    # 暴露端口。 指定两个端口 (HOST:CONTAINER)，或仅指定容器端口（选择临时主机端口）。
    ports:
      - "8080:8080"
    # 定义平台在容器终止时应用的策略。
  #    restart: always

  # todo 有没有比 nginx 更好的选择
  # todo Try using Pingora
  turing-nginx:
    # 指定自定义容器名称，而不是生成的默认名称。
    container_name: turing-nginx
    # 表示服务之间的启动和关闭依赖关系。
    depends_on:
      turing-backend:
        # 设置依赖关系被视为满足的条件。
        condition: service_healthy
    # 声明运行以确定该服务的容器是否“健康”的检查。
    healthcheck:
      # 定义 Compose 运行以检查容器健康状况的命令。
      test: [ "CMD-SHELL", "curl http://localhost:80 | grep -q '^<!doctype html>'" ]
      # 运行状况检查将在容器启动后首先运行间隔秒，然后在之前的每个检查完成后再次运行间隔秒。
      interval: 10s
      # 如果单次运行检查花费的时间超过超时秒数，则检查被视为失败。
      timeout: 10s
      # 需要重试健康检查连续失败才能将容器视为不健康。
      retries: 3
      # 为需要时间引导的容器提供初始化时间。
      start_period: 40s
    # 声明用于服务容器的自定义主机名。
    hostname: turing-nginx
    # 指定启动容器的图像。
    image: nginx:1.29.1
    # 定义服务容器附加到的网络，引用顶级网络键下的条目。
    networks:
      - turing
    # 暴露端口。 指定两个端口 (HOST:CONTAINER)，或仅指定容器端口（选择临时主机端口）。
    ports:
      - "80:80"
    # 定义平台在容器终止时应用的策略。
    restart: always
    # 定义服务容器必须可以访问的挂载主机路径或命名卷。todo logging
    volumes:
      - ./docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf
      - ./docker/nginx/html:/usr/share/nginx/html

  # todo 有没有比 portainer 更好的选择
  turing-portainer:
    # 指定自定义容器名称，而不是生成的默认名称。
    container_name: turing-portainer
    # 声明运行以确定该服务的容器是否“健康”的检查。
    #    healthcheck:
    #      # 定义 Compose 运行以检查容器健康状况的命令。
    #      #      test: [ "CMD-SHELL", "curl --fail http://localhost:9000/api/status || exit 1" ]
    #      #      test: [ "CMD", "wget", "-qO-", "http://localhost:9000/api/status" ]
    #      #      test: [ "CMD-SHELL", "curl -f http://localhost:9000/api/system/status || exit 1" ]
    #      #      test: [ "CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:9000/api/system/status || exit 1" ]
    #      #      test: [ "CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:9000/api/system/status | grep -q '{\"Version\":\"' || exit 1" ]
    #      test: [ "CMD-SHELL", "curl -f http://localhost:9000/api/system/status | grep -q '{\"Version\":\"'" ]
    #      # 运行状况检查将在容器启动后首先运行间隔秒，然后在之前的每个检查完成后再次运行间隔秒。
    #      interval: 10s
    #      # 如果单次运行检查花费的时间超过超时秒数，则检查被视为失败。
    #      timeout: 10s
    #      # 需要重试健康检查连续失败才能将容器视为不健康。
    #      retries: 3
    #      # 为需要时间引导的容器提供初始化时间。
    #      start_period: 40s
    # 声明用于服务容器的自定义主机名。
    hostname: turing-portainer
    # 指定启动容器的图像。
    image: portainer/portainer-ce:2.34.0
    # 定义服务容器附加到的网络，引用顶级网络键下的条目。
    networks:
      - turing
    # 暴露端口。 指定两个端口 (HOST:CONTAINER)，或仅指定容器端口（选择临时主机端口）。
    ports:
      - "9000:9000"
      - "9443:9443"
    # 定义平台在容器终止时应用的策略。
    restart: always
    # 定义服务容器必须可以访问的挂载主机路径或命名卷。todo logging
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
